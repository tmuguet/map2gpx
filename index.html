<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=960">
    <meta name="author" content="Thomas Muguet">

    <title>map2gpx by tmuguet</title>
    <link rel="shortcut icon" href="ico/logo.ico">
    <link rel="apple-touch-icon-precomposed" sizes="144x144" href="ico/logo-144.png">
    <link rel="apple-touch-icon-precomposed" sizes="114x114" href="ico/logo-114.png">
    <link rel="apple-touch-icon-precomposed" sizes="72x72" href="ico/logo-medium-72.png">
    <link rel="apple-touch-icon-precomposed" href="ico/logo-medium-57.png">

    <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

    <script src="https://code.jquery.com/jquery-2.2.4.min.js" integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44=" crossorigin="anonymous"></script>

    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.0.0-rc.3/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.0.0-rc.3/dist/leaflet.js"></script>

    <link rel="stylesheet" href="https://unpkg.com/leaflet-easybutton@2.0.0/src/easy-button.css">
    <script src="https://unpkg.com/leaflet-easybutton@2.0.0/src/easy-button.js"></script>

    <link rel="stylesheet" href="leaflet/GpPluginLeaflet.css" />
    <script data-key="jwwl8p4ie5qcwbgohl0uv7zx" src="leaflet/GpPluginLeaflet.js"></script>

    <link rel="stylesheet" href="leaflet/Control.Loading.css" />
    <script src="leaflet/Control.Loading.js"></script>

    <link rel="stylesheet" href="leaflet/Control.MiniMap.min.css" />
    <script src="leaflet/Control.MiniMap.min.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.5.0/Chart.min.js" integrity="sha256-GcknncGKzlKm69d+sp+k3A2NyQE+jnu43aBl6rrDN2I=" crossorigin="anonymous"></script>

    <script src="js/FileSaver.min.js"></script>

    <style type="text/css">
        .ico {display: inline-block; width: 48px; height: 48px; background-size: contain; background-repeat: no-repeat;}
        .kml {max-width: 256px;max-height: 256px;background-image: url(data:image/svg+xml;utf8;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iaXNvLTg4NTktMSI/Pgo8IS0tIEdlbmVyYXRvcjogQWRvYmUgSWxsdXN0cmF0b3IgMTYuMC4wLCBTVkcgRXhwb3J0IFBsdWctSW4gLiBTVkcgVmVyc2lvbjogNi4wMCBCdWlsZCAwKSAgLS0+CjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+CjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0iQ2FwYV8xIiB4PSIwcHgiIHk9IjBweCIgd2lkdGg9IjI0cHgiIGhlaWdodD0iMjRweCIgdmlld0JveD0iMCAwIDU1MC44MDEgNTUwLjgwMSIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgNTUwLjgwMSA1NTAuODAxOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+CjxnPgoJPGc+CgkJPHBhdGggZD0iTTQ3NS4wOTUsMTMyYy0wLjAzMS0yLjUyOS0wLjgyOC01LjAyMy0yLjU2Mi02Ljk5NUwzNjYuMzI1LDMuNjk0Yy0wLjAyMS0wLjAzMS0wLjA1My0wLjA0Mi0wLjA4NS0wLjA3NCAgICBjLTAuNjMzLTAuNzA5LTEuMzYtMS4yOTItMi4xNDEtMS44MDNjLTAuMjMyLTAuMTUzLTAuNDY0LTAuMjg4LTAuNzA3LTAuNDIyYy0wLjY4Ni0wLjM2OS0xLjM5Mi0wLjY3LTIuMTMtMC44OTIgICAgYy0wLjItMC4wNjEtMC4zOC0wLjE0LTAuNTgtMC4xOTVDMzU5Ljg3LDAuMTE5LDM1OS4wNDgsMCwzNTguMjA0LDBIOTcuMmMtMTEuOTA3LDAtMjEuNiw5LjY5NS0yMS42LDIxLjYwMXY1MDcuNiAgICBjMCwxMS45MTMsOS42OTIsMjEuNjAxLDIxLjYsMjEuNjAxaDM1Ni40YzExLjkxOCwwLDIxLjYtOS42ODgsMjEuNi0yMS42MDFWMTMzLjIxQzQ3NS4yLDEzMi44MDQsNDc1LjEzNywxMzIuMzk4LDQ3NS4wOTUsMTMyeiAgICAgTTE4MC4xNDksNTEyLjcyMWwtMjcuMzgyLTQ4LjI4OWwtOS42MjQsMTEuNzkydjM2LjUwM2gtMjUuMDU0VjQwMC44ODJoMjUuMDU0djQ5LjQzOGgwLjUwNGMyLjQ4OS00LjMxMyw1LjEzOS04LjI5LDcuNjM2LTEyLjI3MSAgICBsMjUuMzg0LTM3LjE2N0gyMDcuN2wtMzcuMDA3LDQ3LjYyNGwzOC45OTUsNjQuMjE1SDE4MC4xNDl6IE0zMTYuMjA2LDUxMi43MjFsLTEuNjU1LTQyLjgxNCAgICBjLTAuNDk2LTEzLjQzOC0xLjAwMi0yOS43LTEuMDAyLTQ1Ljk2NGgtMC40OTZjLTMuNDg1LDE0LjI3NS04LjEyNiwzMC4yMDYtMTIuNDQsNDMuMzExbC0xMy42MSw0My42NDRoLTE5Ljc0NmwtMTEuOTQ0LTQzLjMxMSAgICBjLTMuNjQ5LTEzLjExLTcuNDYyLTI5LjA0Ny0xMC4xMjUtNDMuNjQ0aC0wLjMzNWMtMC42NjUsMTUuMTA0LTEuMTYsMzIuMzUzLTEuOTg1LDQ2LjI5NmwtMS45OTQsNDIuNDc4aC0yMy4zOThsNy4xMzctMTExLjgzOSAgICBoMzMuNjg3bDEwLjk1LDM3LjMzNmMzLjQ4MywxMi45NCw2Ljk2NiwyNi44ODQsOS40NTUsMzkuOTgyaDAuNDk4YzMuMTU0LTEyLjkzNiw2Ljk3Mi0yNy43MTcsMTAuNjIxLTQwLjE1N2wxMS45NDQtMzcuMTY3aDMzLjAyMiAgICBsNi4xMzgsMTExLjgzOWgtMjQuNzIyVjUxMi43MjF6IE00MzAuMTkxLDUxMi43MjFoLTY5Ljg2N1Y0MDAuODgyaDI1LjM5MnY5MC42MDNoNDQuNDc2VjUxMi43MjF6IE05Ny4yLDM2Ni43NThWMjEuNjA1aDI1MC4yMDQgICAgdjExMC41MTljMCw1Ljk2MSw0LjgzLDEwLjgsMTAuOCwxMC44aDk1LjM5NmwwLjAxMSwyMjMuODM0SDk3LjJ6IiBmaWxsPSIjMDAwMDAwIi8+CgkJPGc+CgkJCTxwYXRoIGQ9Ik0yNzIuMDI1LDY0LjUwNWM3Mi40NTItMC4yNzYsMTMyLjg5MSw1OS4wMzQsMTMyLjc0OCwxMzIuOTJjLTAuMTQzLDcyLjEwMS01OS41NDIsMTMzLjA0Ni0xMzMuODU1LDEzMi40ODEgICAgIGMtNzIuODM5LTAuNTU5LTEzMS42NjItNjEuNjA2LTEzMS40MjUtMTMzLjMxMkMxMzkuNzM2LDEyNC4xMzcsMTk5LjQ3Niw2NC4yOTksMjcyLjAyNSw2NC41MDV6IE0xNTQuNDYyLDE2MS4xOTYgICAgIGMwLjQzMywwLjMwOSwwLjg2NSwwLjYwNiwxLjI5NSwwLjkxMmMxLjMxMy0wLjc5NCwyLjczNC0xLjQ2MywzLjkxLTIuNDE4YzIuNjE4LTIuMTM4LDUuMDctNC40OTgsNy42NzMtNi42NTcgICAgIGMxNS42MTctMTIuOTY4LDMyLjYxNi0xNi43NTcsNTEuMzcxLTcuMzE3YzYuMzQ0LDMuMTksMTIuNjk2LDYuNTE2LDE4LjYwMiwxMC40MzdjMjYuMTA5LDE3LjMyOCw1MS42NzEsMzUuNTIxLDc4LjIwOCw1Mi4xNjUgICAgIGMyMC45OTksMTMuMTgxLDQzLjg3LDIyLjYxLDY4LjQ2LDI3LjM4MmMzLjc5NywwLjc0MSw1LjUtMC4yNTMsNi4yMjMtMy42NDRjMC45OTEtNC42MTcsMS41NjYtOS4zMzcsMi44MTYtMTMuODc3ICAgICBjMC44MzMtMi45ODctMC4yNzQtNC4wOTUtMi44MTItNC42ODhjLTEzLjA3Mi0zLjA4Mi0yNS4wNjktOC44NzgtMzUuNDk1LTE3LjAxYy0xOS4wNjgtMTQuODgxLTM3LjYtMzAuNDc4LTU2LjA4My00Ni4xMDUgICAgIGMtMTIuNzg4LTEwLjgyNi0yNC45NC0yMi40MDktMzcuNjg3LTMzLjMwMmMtMTcuMzA1LTE0Ljc2OS0zNy41ODktMTcuNDk3LTU5LjE3My0xMy4xNzZjLTUuMzI5LDEuMDYyLTExLjU4OCwyLjI1Mi0xNS4zMjUsNS42NjQgICAgIGMtMTIuODUyLDExLjc1Mi0yMy4wNDIsMjUuNzE2LTI5LjEzMyw0Mi4yODJDMTU2LjE4OSwxNTQuODk1LDE1NS40LDE1OC4wOCwxNTQuNDYyLDE2MS4xOTZ6IE0zNzMuNTEzLDI2Ni41OTkgICAgIGMtMC40OS0wLjUyOS0wLjk3Ni0xLjA0Ni0xLjQ3Mi0xLjU3NmMtMS41NzEsMC4zOTYtMy4xNDMsMC43NTctNC43MDMsMS4xODRjLTE2LjY3NSw0LjU2Ny0zMy41OTgsOC41NjQtNTAuODk5LDcuNjk5ICAgICBjLTE0LjkzOS0wLjc1MS0yOS45MjItMi43ODctNDQuNjI0LTUuNTc5Yy0yNS40MjMtNC44MzEtNDguOTc3LTE1LjQxNC03Mi43OTItMjUuMTk2Yy03LjUzOC0zLjA5My0xNS43MDQtNS43NjItMjMuNzM4LTYuMzA4ICAgICBjLTEwLjc0Ny0wLjczMi0xNi42NDgsMTAuMTM2LTExLjU0MSwxOS40MmMxMi4wMSwyMS44MjEsMjkuMDQ5LDM4LjU4Niw1MS4wNzMsNTAuMjI5YzEuNzY3LDAuOTI4LDMuNzg2LDEuMzcxLDYuNjkyLDIuMzk5ICAgICBjLTAuNTgzLTIuODk2LTAuODM5LTQuNTItMS4yMzctNi4wOTdjLTIuOTE3LTExLjU4NSwxLjgxNC0xNi40MzcsMTMuNjg3LTEzLjk5YzEuNjUzLDAuMzQzLDMuMzEyLDAuNjc1LDQuOTUyLDEuMTA3ICAgICBjMjguNTcxLDcuMzcyLDU3LjQzLDEwLjgyMSw4Ni44NzIsNi4zODFjMTUuNTYyLTIuMzUyLDMwLjc4Ni01LjM3NCw0MC41MjYtMTkuNzIzICAgICBDMzY4LjYwOCwyNzMuMTU0LDM3MS4xMTMsMjY5LjkwMywzNzMuNTEzLDI2Ni41OTl6IE0yMzYuOTMxLDc5Ljc0OGMwLjA4NywwLjcwNywwLjE3MSwxLjQwNSwwLjI1OCwyLjExMiAgICAgYzEuMjM3LDAuMjA2LDIuNDYzLDAuNTQ2LDMuNywwLjYwNGM2LjQxNSwwLjM1OCwxMi44MywwLjU4NSwxOS4yNCwwLjk3M2MyMy40NTcsMS40MjEsNDQuMTQ5LDkuODUxLDYwLjA1NCwyNy4xMDggICAgIGMxMi4zNTUsMTMuMzg3LDIyLjc0NCwyOC41ODIsMzQuMzgzLDQyLjY1NGM1LjEzNiw2LjIyNSwxMC44MTUsMTIuMTM5LDE2Ljk1NCwxNy4zNzhjNC42MTQsMy45MzcsMTAuMTcyLDMuMzc1LDE0LjA3NCwwLjE5MiAgICAgYzQuMjYyLTMuNDc4LDQuOTQ3LTYuNzg3LDIuNzY5LTEzLjIzOWMtNy42OTMtMjIuODA1LTIxLjE1MS00MS43LTQwLjEzNi01Ni4yNTJjLTI3LjUyNy0yMS4xMi01OC43MjUtMzAuMDQ4LTkzLjM3OS0yNS40NDQgICAgIEMyNDguODE3LDc2LjYzMSwyNDIuOTAzLDc4LjQxOSwyMzYuOTMxLDc5Ljc0OHoiIGZpbGw9IiMwMDAwMDAiLz4KCQk8L2c+Cgk8L2c+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPC9zdmc+Cg==)}
        .gpx {max-width: 256px;max-height: 256px;background-image: url(data:image/svg+xml;utf8;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iaXNvLTg4NTktMSI/Pgo8IS0tIEdlbmVyYXRvcjogQWRvYmUgSWxsdXN0cmF0b3IgMTYuMC4wLCBTVkcgRXhwb3J0IFBsdWctSW4gLiBTVkcgVmVyc2lvbjogNi4wMCBCdWlsZCAwKSAgLS0+CjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+CjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0iQ2FwYV8xIiB4PSIwcHgiIHk9IjBweCIgd2lkdGg9IjI0cHgiIGhlaWdodD0iMjRweCIgdmlld0JveD0iMCAwIDU1MC44MDEgNTUwLjgwMSIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgNTUwLjgwMSA1NTAuODAxOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+CjxnPgoJPGc+CgkJPGc+CgkJCTxwYXRoIGQ9Ik0yODAuNTM3LDQxNC43ODhjLTUuNTg1LDAtOS4zNzEsMC41NDMtMTEuMzUyLDEuMDg2djM1Ljg0OWMyLjM0MiwwLjU0OSw1LjIyMSwwLjcyOSw5LjE4NCwwLjcyOSAgICAgYzE0LjU5MiwwLDIzLjYwNC03LjM5NCwyMy42MDQtMTkuODE4QzMwMS45NzQsNDIxLjQ2NCwyOTQuMjI3LDQxNC43ODgsMjgwLjUzNyw0MTQuNzg4eiIgZmlsbD0iIzAwMDAwMCIvPgoJCQk8cGF0aCBkPSJNNDc1LjA5NSwxMzEuOTkyYy0wLjAzMS0yLjUyNi0wLjgyOC01LjAyMS0yLjU2Mi02Ljk5M0wzNjYuMzI1LDMuNjk0Yy0wLjAyMS0wLjAzMS0wLjA1My0wLjA0Mi0wLjA4NS0wLjA3NiAgICAgYy0wLjYzMy0wLjcwNy0xLjM2LTEuMjktMi4xNDEtMS44MDRjLTAuMjMyLTAuMTUtMC40NjQtMC4yODUtMC43MDctMC40MTljLTAuNjg2LTAuMzY5LTEuMzkyLTAuNjctMi4xMy0wLjg5MiAgICAgYy0wLjItMC4wNjEtMC4zOC0wLjE0My0wLjU4LTAuMTk1QzM1OS44NywwLjExOSwzNTkuMDQ4LDAsMzU4LjIwNCwwSDk3LjJjLTExLjkwNywwLTIxLjYsOS42OTMtMjEuNiwyMS42MDF2NTA3LjYgICAgIGMwLDExLjkxMyw5LjY5MiwyMS42MDEsMjEuNiwyMS42MDFoMzU2LjRjMTEuOTE4LDAsMjEuNi05LjY4OCwyMS42LTIxLjYwMVYxMzMuMjAyICAgICBDNDc1LjIsMTMyLjc5OSw0NzUuMTM3LDEzMi4zOTgsNDc1LjA5NSwxMzEuOTkyeiBNMjIwLjU2Miw1MTAuODE3Yy04LjQ2NiwyLjg4NS0yNC40OTgsNi44NDUtNDAuNTMyLDYuODQ1ICAgICBjLTIyLjE2MiwwLTM4LjE4OC01LjU3NC00OS4zNjItMTYuMzljLTExLjE3MS0xMC40NTItMTcuMjk0LTI2LjI5OS0xNy4xMTctNDQuMTI4YzAuMTg1LTQwLjM2MywyOS41NS02My40MTksNjkuMzY0LTYzLjQxOSAgICAgYzE1LjY3LDAsMjcuNzQzLDMuMDQ4LDMzLjY4NCw1LjkzOGwtNS43NjEsMjEuOTg0Yy02LjY2OC0yLjg5LTE0Ljk1My01LjIzNi0yOC4yODQtNS4yMzZjLTIyLjg4MiwwLTQwLjE3MywxMi45NzMtNDAuMTczLDM5LjI4NyAgICAgYzAsMjUuMDM4LDE1LjY3MiwzOS44MDQsMzguMTk1LDM5LjgwNGM2LjMwNywwLDExLjM0Ni0wLjcxNywxMy41MTEtMS43OTN2LTI1LjQwN2gtMTguNzQ1di0yMS40NDFoNDUuMjI1djYzLjk1NkgyMjAuNTYyeiAgICAgIE0zMTguMDEsNDYwLjczYy05LjM2NSw4LjgzOC0yMy4yNCwxMi43OTMtMzkuNDU2LDEyLjc5M2MtMy42MDIsMC02Ljg0OC0wLjE4LTkuMzYzLTAuNTQzdjQzLjQyMWgtMjcuMjA2VjM5Ni41OTUgICAgIGM4LjQ2Ni0xLjQzNSwyMC4zNTgtMi41MjEsMzcuMTE0LTIuNTIxYzE2LjkzMSwwLDI5LjAwNywzLjI0OCwzNy4xMDYsOS43MzRjNy43NTIsNi4xMjIsMTIuOTczLDE2LjIxMSwxMi45NzMsMjguMDk3ICAgICBDMzI5LjE3OSw0NDMuODAzLDMyNS4yMTMsNDUzLjg5NiwzMTguMDEsNDYwLjczeiBNNDA1LjU0OSw1MTYuNDA3bC0xMC45OS0yMS45NzljLTQuNTAzLTguNDY0LTcuMzgzLTE0Ljc3MS0xMC44LTIxLjgwMWgtMC4zNjMgICAgIGMtMi41MjYsNy4wMjktNS41ODUsMTMuMzM3LTkuMzcxLDIxLjgwMWwtMTAuMDgzLDIxLjk3OWgtMzEuMzUxbDM1LjEyNi02MS40NDFsLTMzLjg2NS01OS45ODVoMzEuNTI5bDEwLjYyNiwyMi4xNjUgICAgIGMzLjYwMiw3LjM4OCw2LjMwOCwxMy4zMzYsOS4xOTEsMjAuMTcxaDAuMzU0YzIuODktNy43NDIsNS4yMzEtMTMuMTU3LDguMjktMjAuMTcxbDEwLjI2OC0yMi4xNjVoMzEuMzUxbC0zNC4yMzUsNTkuMjc5ICAgICBsMzYuMDI4LDYyLjE1MmgtMzEuNzA0VjUxNi40MDd6IE05Ny4yLDM2Ni43NTJWMjEuNjAxaDI1MC4yMDR2MTEwLjUxOGMwLDUuOTU5LDQuODMsMTAuOCwxMC44LDEwLjhoOTUuMzk2bDAuMDExLDIyMy44MzNIOTcuMnoiIGZpbGw9IiMwMDAwMDAiLz4KCQk8L2c+CgkJPGc+CgkJCTxnPgoJCQkJPHBhdGggZD0iTTM4My4yMTEsMjQ1LjU0NWwtNS4xODUtMTkuNjE1Yy0xMy42NzQsMy4yODMtMzAuOTcxLDkuMTg2LTUwLjAwOCwxOS42MTVIMzgzLjIxMXoiIGZpbGw9IiMwMDAwMDAiLz4KCQkJPC9nPgoJCQk8Zz4KCQkJCTxwYXRoIGQ9Ik0zODUuNTg0LDI1NC41MzZoLTcyLjUyMWMtMjIuMDAxLDE0LjMzNi00NS41NzMsMzQuODMzLTY4LjIzOCw2NC40MjNoMTU3Ljc4MUwzODUuNTg0LDI1NC41MzZ6IiBmaWxsPSIjMDAwMDAwIi8+CgkJCTwvZz4KCQkJPGc+CgkJCQk8cGF0aCBkPSJNMjY5LjY3MSwxNzEuNTE3Yy0yLjYxOC03LjA4NS01LjQ5Mi0xNC44NC04LjMyNy0yMi41NzloLTkwLjAxMmwtMTAuNzM3LDQwLjY1Nmg4Ny42MjYgICAgICBDMjUxLjQ4OCwxODEuNzQ0LDI1OS4zNDYsMTc1LjI0MiwyNjkuNjcxLDE3MS41MTd6IiBmaWxsPSIjMDAwMDAwIi8+CgkJCTwvZz4KCQkJPGc+CgkJCQk8cGF0aCBkPSJNMjg5LjYwMiwyNTQuNTM2SDE0My40NDZsLTE3LjAxNSw2NC40MjNoMTAxLjIyNkMyMzkuOTIzLDMwMC45MjQsMjYwLjI5NywyNzUuODgsMjg5LjYwMiwyNTQuNTM2eiIgZmlsbD0iIzAwMDAwMCIvPgoJCQk8L2c+CgkJCTxnPgoJCQkJPHBhdGggZD0iTTM3NS41MTIsMjE2LjM4OGwtMTcuODE0LTY3LjQ1aC0zOC40OTZjLTMuMTMyLDcuNDkxLTYuMzgxLDE1LjE1My05LjU2MSwyMi42MjUgICAgICBjMTMuNzQ4LDQuOTM3LDIzLjE5OCwxNC43MSwyMy4xOTgsMjYuMDg4YzAsMTYuMzEzLTE5LjM1NCwyOS41NjUtNDMuMjIyLDI5LjU2NWMtMjAuNjY0LDAtMzcuOTAyLTkuOTU5LTQyLjE2My0yMy4xOThIMTU2Ljc5ICAgICAgbC0xMC45NzksNDEuNTIxSDMwMi45OEMzMjMuMzg5LDIzMi43NDEsMzQ3LjQ0NiwyMjIuMDYsMzc1LjUxMiwyMTYuMzg4eiIgZmlsbD0iIzAwMDAwMCIvPgoJCQk8L2c+CgkJCTxnPgoJCQkJPHBhdGggZD0iTTI4My40NDcsMTgxLjAwOWMtMTAuMzA5LDEuNzkzLTE3Ljk0LDcuODczLTE3Ljk0LDE1LjE0N2MwLDguNjgzLDEwLjc5NCwxNS43MDIsMjQuMSwxNS43MDIgICAgICBjMTMuMzEsMCwyNC4wOTQtNy4wMiwyNC4wOTQtMTUuNzAyYzAtNy4zMTItNy42OTMtMTMuNDA3LTE4LjA3Mi0xNS4xNjRjOS41NTYtMjIuMjU0LDI2LjYyMS02Mi4yMjksMzAuMDM4LTcyLjM3ICAgICAgYzEuNDk3LTMuOTk4LDIuMzU3LTguMzExLDIuMzU3LTEyLjgyNWMwLTIwLjIxOS0xNi4zOTYtMzYuNjE5LTM2LjYxOS0zNi42MTljLTIwLjIzNCwwLTM2LjYxNiwxNi40LTM2LjYxNiwzNi42MTkgICAgICBjMCwzLjk0MSwwLjY0MSw3Ljc0NCwxLjc5OCwxMS4zMDZDMjU4LjQ2NSwxMTMuNzM1LDI3NC42NDksMTU3LjQwNCwyODMuNDQ3LDE4MS4wMDl6IE0zMDQuMjYyLDE5Ni4xNTYgICAgICBjMCw1LjI3Ni02LjU2LDkuNTU5LTE0LjY1NCw5LjU1OXMtMTQuNjU1LTQuMjgyLTE0LjY1NS05LjU1OWMwLTQuMzksNC41NDYtOC4wNDcsMTAuNzEtOS4xNjUgICAgICBjMi4wODksNS41NTgsMy40MjgsOS4xNjUsMy40MjgsOS4xNjVzMS41NzctMy42NDEsNC4wMDgtOS4yNzNDMjk5LjQ5NSwxODcuOTIyLDMwNC4yNjIsMTkxLjY1OCwzMDQuMjYyLDE5Ni4xNTZ6IE0yOTEuNCw3Mi41NzEgICAgICBjMTIuODk4LDAsMjMuMzYxLDEwLjQ1OSwyMy4zNjEsMjMuMzcyYzAsMTIuODk0LTEwLjQ2MywyMy4zMzgtMjMuMzYxLDIzLjMzOGMtMTIuOTEyLDAtMjMuMzYyLTEwLjQ0OS0yMy4zNjItMjMuMzM4ICAgICAgQzI2OC4wNDQsODMuMDMsMjc4LjQ5Myw3Mi41NzEsMjkxLjQsNzIuNTcxeiIgZmlsbD0iIzAwMDAwMCIvPgoJCQk8L2c+CgkJPC9nPgoJPC9nPgo8L2c+CjxnPgo8L2c+CjxnPgo8L2c+CjxnPgo8L2c+CjxnPgo8L2c+CjxnPgo8L2c+CjxnPgo8L2c+CjxnPgo8L2c+CjxnPgo8L2c+CjxnPgo8L2c+CjxnPgo8L2c+CjxnPgo8L2c+CjxnPgo8L2c+CjxnPgo8L2c+CjxnPgo8L2c+CjxnPgo8L2c+Cjwvc3ZnPgo=)}
    </style>
</head>

<body>
    <div style="display: none"><div id="welcome">
        This <strong>map2gpx</strong> tool lets you trace paths (for hiking for instance) and export them to GPX or KML formats. As it is using data from <a href="https://www.geoportail.gouv.fr/">Géoportail</a>, it will most likely only work with paths in France.<hr/>
        To start your trace, double-click to add a first marker at your starting point.<br>
        Double click to add new markers at waypoints; the path is automatically computed, following known trails.<br>
        You can move markers by dragging them, or delete them by clicking on them and select "Delete this marker".<br/>
        You can close the loop of your trace via the <i class="fa fa-magic"></i> button on the top-left side of the map.<br/>
        Once you are done, you can export it via the <i class="fa fa-cloud-download"></i> button.
    </div></div>
    <div style="display: none"><div id="about">
        This tool was created by <a href="https://tmuguet.me">Thomas Muguet</a>, licensed under MIT license and its source code is available on <a href="https://github.com/tmuguet/map2gpx">GitHub</a> (you'll need your own <a href="http://professionnels.ign.fr/">Géoservices API key</a> though).<hr/>
        Uses:
        <ul>
            <li><a href="http://fontawesome.io">Font Awesome</a> by Dave Gandy (SIL OFL 1.1)</li>
            <li><a href="http://jquery.com/">jQuery</a> (MIT license)</li>
            <li><a href="http://leafletjs.com/">Leaflet</a> (BSD 2-clause "Simplified" License)</li>
            <li><a href="https://github.com/CliffCloud/Leaflet.EasyButton">L.EasyButton</a> (MIT license)</li>
            <li><a href="https://github.com/IGNF/geoportal-extensions">Extensions Géoportail</a> (CeCILL-B)</li>
            <li><a href="https://github.com/ebrelsford/Leaflet.loading">Leaflet.loading</a> (MIT license)</li>
            <li><a href="https://github.com/Norkart/Leaflet-MiniMap">Leaflet.MiniMap</a> (BSD 2-clause "Simplified" License)</li>
            <li><a href="https://github.com/eligrey/FileSaver.js/">FileSaver.js</a> (MIT license)</li>
            <li>KML and GPX icons by <a href="http://www.freepik.com" title="Freepik">Freepik</a> from <a href="http://www.flaticon.com" title="Flaticon">www.flaticon.com</a> (<a href="http://creativecommons.org/licenses/by/3.0/" title="Creative Commons BY 3.0" target="_blank">CC 3.0 BY</a>)</li>
        </ul>
    </div></div>
    <div id="map" style="display: block; position: absolute; top: 0px; left: 0px; right: 0px; bottom: 150px;"></div>
    <div id="data-list" style="display: block; position: absolute; height: 150px; left: 0px; width: 30%; bottom: 0px;">
        <ul><li>Distance: <span id="data-distance"></span></li>
            <li>Altitude min: <span id="data-alt-min"></span></li>
            <li>Altitude max: <span id="data-alt-max"></span></li>
            <li>Dénivelé +: <span id="data-deniv-pos"></span></li>
            <li>Dénivelé -: <span id="data-deniv-neg"></span></li>
        </ul>
    </div>
    <div id="data" style="display: block; position: absolute; height: 150px; left: 30%; right: 0px; bottom: 0px;">
        <canvas id="chart" width="100%" height="100%"></canvas>
    </div>
    <canvas id="canvas" style="display: none"></canvas>

    <script type="text/javascript">
window.onload = function() {
    var keyIgn = 'jwwl8p4ie5qcwbgohl0uv7zx';


    var markers = [];   // Cache of defined markers
    var routes = [];    // Cache of computed routes
    var altitudes = {}; // Cache of computed altitudes for each points of routes computed so far
    var slopes = {}; // Cache of computed slopes for each points of routes computed so far

    // Central map
    var map = L.map('map', {
        loadingControl: true,
        doubleClickZoom: false
    }).setView([44.97755, 6.141186], 13);   // Center in les Ecrins because I love this place
    L.geoportalLayer.WMTS({
        layer: "ORTHOIMAGERY.ORTHOPHOTOS",
        apiKey: keyIgn
    }).addTo(map);
    var slopes =  L.geoportalLayer.WMTS({
        layer: "GEOGRAPHICALGRIDSYSTEMS.SLOPES.MOUNTAIN",
        apiKey: keyIgn
    }, {
        opacity: 0.25
    }).addTo(map);
    L.geoportalLayer.WMTS({
        layer: "GEOGRAPHICALGRIDSYSTEMS.MAPS",
        apiKey: keyIgn
    }, {
        opacity: 0.25
    }).addTo(map);

    // Add controls
    // Mini-map
    var miniMapLayer = L.geoportalLayer.WMTS({
        layer: "GEOGRAPHICALGRIDSYSTEMS.MAPS",
        apiKey: keyIgn
    });
    var miniMap = new L.Control.MiniMap(miniMapLayer, {
        'position': 'bottomleft',
        'zoomLevelOffset': -4
    }).addTo(map);
    var layerSwitcher = L.geoportalControl.LayerSwitcher({
        collapsed : false,
        layers : [{
            layer: slopes,
            config: {
                visibility: false
            }
        }]
    });
    map.addControl(layerSwitcher);

    map.addControl(L.control.scale({
        'imperial': false,
        'position': 'bottomright'
    }));

    var closeLoop = L.easyButton({
        states: [{
            stateName: 'loaded',
            icon: 'fa-magic',
            title: 'Close the loop',
            onClick: function(btn, map) {
                if (markers.length > 1) {
                    var first = markers[0];
                    addMarker({
                        latlng: first.getLatLng()
                    });
                }
            }
        }, {
            stateName: 'computing',
            icon: 'fa-spinner fa-pulse',
            title: 'Close the loop (computing...)'
        }]
    }).addTo(map);
    var exportPopup = L.popup().setContent('<input type="text" value="filename" class="export-filename"/><br/><button class="export-gpx-button"><span class="ico gpx"></span></button><button class="export-kml-button"><span class="ico kml"></span></button>');
    var exportButton = L.easyButton({
        states: [{
            stateName: 'loaded',
            icon: 'fa-cloud-download',
            title: 'Export',
            onClick: function(btn, map) {
                exportPopup.setLatLng(markers[0].getLatLng()).openOn(map);
                var o = this;
                $(".export-gpx-button:visible").click(function() {
                    var btn = $(this);
                    btn.attr("disabled", "disabled");
                    $.when(exportGpx($(".export-filename:visible").val())).then(function() {
                        btn.removeAttr("disabled");
                    });
                });
                $(".export-kml-button:visible").click(function() {
                    var btn = $(this);
                    btn.attr("disabled", "disabled");
                    $.when(exportKml($(".export-filename:visible").val())).then(function() {
                        btn.removeAttr("disabled");
                    });
                });
            }
        }, {
            stateName: 'computing',
            icon: 'fa-spinner fa-pulse',
            title: 'Export (computing...)'
        }]
    }).addTo(map);
    var infoPopup = L.popup().setContent(L.DomUtil.get("about"));
    var infoButton = L.easyButton({
        position: 'bottomright',
        states: [{
            icon: 'fa-info-circle',
            onClick: function(btn, map) {
                infoPopup.setLatLng(map.getCenter()).openOn(map);
            },
            title: 'About & credits'
        }]
    }).addTo(map);

    var welcomePopup = L.popup().setContent(L.DomUtil.get("welcome"));
    welcomePopup.setLatLng(map.getCenter()).openOn(map);

    // Map interactions
    map.on('dblclick', addMarker);


    // Logic
    function updateButtons(enabled) {
        if (enabled) {
            closeLoop.state('loaded');
            exportButton.state('loaded');
            if (markers.length > 1) {
                closeLoop.enable();
                exportButton.enable();
            } else {
                closeLoop.disable();
                exportButton.disable();
            }
        } else {
            closeLoop.state('computing');
            exportButton.state('computing');
            closeLoop.disable();
            exportButton.disable();
        }
    }
    updateButtons(true);

    function latlngToTilePixel(latlng, crs, zoom, tileSize, pixelOrigin) {
        const layerPoint = crs.latLngToPoint(latlng, zoom).floor()
        const tile = layerPoint.divideBy(tileSize).floor()
        const tileCorner = tile.multiplyBy(tileSize).subtract(pixelOrigin)
        const tilePixel = layerPoint.subtract(pixelOrigin).subtract(tileCorner)
        return [tile, tilePixel];
    }

    function computeRoute(start, end, index) {
        return $.Deferred(function() {
            var self = this;
            if (index === undefined) index = -1; // push to the end
            var options = {
                distanceUnit: "m",
                endPoint: {
                    x: end.lng,
                    y: end.lat
                },
                exclusions: [],
                geometryInInstructions: true,
                graph: "Pieton",
                routePreferences: "fastest",
                startPoint: {
                    x: start.lng,
                    y: start.lat
                },
                viaPoints: [],
                apiKey: keyIgn,
                onSuccess: function(results) {
                    if (results) {
                        var geojson = L.geoJSON([], {
                            color: "#ED7F10",
                            weight: 5,
                            opacity: 0.75
                        }).addTo(map);

                        var _geometry = {
                            type: "FeatureCollection",
                            features: []
                        };
                        var counter = 1;
                        $.each(results.routeInstructions, function(idx, instructions) {
                            counter++;
                            _geometry.features.push({
                                id: counter,
                                type: "Feature",
                                geometry: instructions.geometry
                            });
                        });
                        geojson.addData(_geometry);

                        if (index == -1) {
                            // Adding route at the end
                            routes.push(geojson);
                        } else {
                            // Replace route at index
                            routes[index] = geojson;
                        }

                        var promises = fetchAltitudeOfFeature(geojson).concat(fetchSlopeOfFeature(geojson));
                        // Resolve this deffered when all altitudes+slopes are computed
                        $.when.apply($, promises).then(function() {
                            geojson.eachLayer(function(layer) {
                                $.each(layer.feature.geometry.coordinates, function(j, coords) {
                                    if (coords[0] + '/' + coords[1] in altitudes) {
                                        coords[2] = altitudes[coords[0] + '/' + coords[1]]; // updates ref
                                    }
                                    if (coords[0] + '/' + coords[1] in slopes) {
                                        coords[3] = slopes[coords[0] + '/' + coords[1]]; // updates ref
                                    }
                                });
                            });
                            replot().then(function() {
                                self.resolve();
                            });
                        });
                    }
                },
                onFailure: function(error) {
                    console.log(error.message);
                    self.resolve();
                }
            };
            Gp.Services.route(options);
        });
    }

    function addMarker(e) {
        updateButtons(false); // Disabled while computations
        var promises = [];

        var marker = L.marker(e.latlng, {
            riseOnHover: true,
            draggable: true,
        }).bindPopup("<input type='button' value='Delete this marker' class='marker-delete-button'/>");
        marker.on("popupopen", function() {
            var o = this;
            $(".marker-delete-button:visible").click(function() {
                map.removeLayer(o); // Routes will be deleted when marker gets deleted
            });
        });
        markers.push(marker);
        marker.addTo(map);

        if (markers.length > 1) {
            // Compute route between this new marker and the previous one
            var markerIndex = markers.length - 1;
            var start = markers[markerIndex - 1].getLatLng(); // previous
            var end = markers[markerIndex].getLatLng(); // this
            promises.push(computeRoute(start, end)); // should be inserted at index markerIndex-1
        }

        marker.on('moveend', function(event) {
            // Update routes when moving this marker
            updateButtons(false);
            var promises = [];

            var markerIndex = markers.indexOf(event.target);
            if (markerIndex > -1 && routes.length > 0) {
                if (markerIndex < markers.length - 1) {
                    // Re-compute route starting at this marker
                    var routeFrom = routes[markerIndex];

                    map.removeLayer(routeFrom);

                    var start = markers[markerIndex].getLatLng();
                    var end = markers[markerIndex + 1].getLatLng();
                    promises.push(computeRoute(start, end, markerIndex));
                }

                if (markerIndex > 0) {
                    // Re-compute route ending at this marker
                    var routeTo = routes[markerIndex - 1];

                    map.removeLayer(routeTo);

                    var start = markers[markerIndex - 1].getLatLng();
                    var end = markers[markerIndex].getLatLng();
                    promises.push(computeRoute(start, end, markerIndex - 1));
                }
            }

            $.when.apply($, promises).then(function() {
                updateButtons(true);
            });
        });

        marker.on('remove', function(event) {
            // Remove/update routes when removing this marker
            updateButtons(false);
            var promises = [];

            var markerIndex = markers.indexOf(event.target);
            if (markerIndex > -1) {
                if (markerIndex == 0) {
                    if (routes.length > 0) {
                        // Remove route starting at this marker
                        var routeFrom = routes[0];

                        map.removeLayer(routeFrom);
                        routes.splice(0, 1);

                        promises.push(replot());
                    }
                } else if (markerIndex == markers.length - 1) {
                    // Remove route ending at this marking
                    var routeTo = routes[markerIndex - 1];

                    map.removeLayer(routeTo);
                    routes.splice(markerIndex - 1, 1);

                    promises.push(replot());
                } else {
                    // Remove route ending at this marker & route starting at this marker
                    var routeTo = routes[markerIndex - 1];
                    var routeFrom = routes[markerIndex];
                    map.removeLayer(routeTo);
                    map.removeLayer(routeFrom);

                    routes.splice(markerIndex, 1); // Remove route starting at this marker

                    // Re-compute new route between previous & next markers
                    var start = markers[markerIndex - 1].getLatLng();
                    var end = markers[markerIndex + 1].getLatLng();
                    promises.push(computeRoute(start, end, markerIndex - 1));
                }
                markers.splice(markerIndex, 1);
            }
            $.when.apply($, promises).then(function() {
                updateButtons(true);
            });
        });

        $.when.apply($, promises).then(function() {
            updateButtons(true);
        });
    }

    function fetchAltitudeOfFeature(geojson) {
        var geometry = []; // Batch
        var promises = [];
        geojson.eachLayer(function(layer) {
            $.each(layer.feature.geometry.coordinates, function(j, coords) {
                if (!(coords[0] + '/' + coords[1] in altitudes)) { // Ignore already cached values
                    geometry.push({
                        lon: coords[0],
                        lat: coords[1]
                    });
                    if (geometry.length == 50) {
                        // Launch batch
                        promises.push(fetchAltitude(geometry));
                        geometry = [];
                    }
                }
            });
        });
        if (geometry.length > 0) {
            // Launch last batch
            promises.push(fetchAltitude(geometry));
        }
        return promises;
    }

    function fetchAltitude(geometry) {
        return $.Deferred(function() {
            var self = this;
            var options = {
                apiKey: keyIgn,
                sampling: geometry.length,
                positions: geometry,
                onSuccess: function(result) {
                    if (result) {
                        $.each(result.elevations, function(i, val) {
                            var key = val.lon + '/' + val.lat;
                            altitudes[key] = val.z;
                        });
                    }
                    self.resolve();
                },
                /** callback onFailure */
                onFailure: function(error) {
                    console.log(error.message);
                    self.resolve();
                }
            };
            // Request altitude service
            Gp.Services.getAltitude(options);
        });
    }

    function fetchSlopeOfFeature(geojson) {
        var tiles = {};
        geojson.eachLayer(function(layer) {
            $.each(layer.feature.geometry.coordinates, function(j, coords) {
                var tile = latlngToTilePixel(L.latLng(coords[1], coords[0]), map.options.crs, 16, 256, map.getPixelOrigin());

                if (!(tile[0].x in tiles))
                    tiles[tile[0].x] = {};
                if (!(tile[0].y in tiles[tile[0].x]))
                    tiles[tile[0].x][tile[0].y] = [];

                tiles[tile[0].x][tile[0].y].push({lat: coords[1], lon: coords[0], z: coords[2], x: tile[1].x, y: tile[1].y});
            });
        });

        var promises = [];
        $.each(tiles, function(x, _y) {
            $.each(_y, function(y, val) {
                promises.push(fetchSlope(x, y, val));
            });
        });
        return promises;
    }

    function fetchSlope(tilex, tiley, coords) {
        return $.Deferred(function() {
            var self = this;

            var data = {
                tilematrix: 16, tilerow: tiley, tilecol: tilex, lon: '', lat: '', x: '', y: ''
            };

            $.each(coords, function(idx, coord) {
                if (idx > 0) {
                    data.lon += '|';
                    data.lat += '|';
                    data.x += '|';
                    data.y += '|';
                }

                data.lon += coord.lon.toString();
                data.lat += coord.lat.toString();
                data.x += coord.x.toString();
                data.y += coord.y.toString();
            });

            $.getJSON("slope.php", data, function (r) {
                if (r.results) {
                    $.each(r.results, function(i, val) {
                        var key = val.lon + '/' + val.lat;
                        slopes[key] = val.slope;
                    });
                }
                self.resolve();
            });
        });
    }

    function exportGpx(filename) {
        return $.Deferred(function() {
            var self = this;
            try {
                var isFileSaverSupported = !! new Blob;
            } catch (e) {}
            if (!isFileSaverSupported) { /* can't check this until Blob polyfill loads above */
                return false;
            }
            var promises = [];
            $.each(routes, function(i, geojson) {
                Array.prototype.push.apply(promises, fetchAltitudeOfFeature(geojson));
            });

            $.when.apply($, promises).then(function() {
                var xml = '<?xml version="1.0"?>\n';
                xml += '<gpx creator="Foobar" version="1.0" xmlns="http://www.topografix.com/GPX/1/1" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd">\n';
                xml += '    <trk>\n';
                xml += '        <name>' + filename + '</name>\n';
                xml += '        <trkseg>\n';
                $.each(routes, function(i, group) {
                    group.eachLayer(function(layer) {
                        $.each(layer.feature.geometry.coordinates, function(j, coords) {
                            xml += '            <trkpt lat="' + coords[1] + '" lon="' + coords[0] + '">';
                            if (coords[0] + '/' + coords[1] in altitudes) {
                                xml += '<ele>' + altitudes[coords[0] + '/' + coords[1]] + '</ele>';
                            }
                            xml += '</trkpt>\n';
                        });
                    });
                });
                xml += '        </trkseg>\n    </trk>\n</gpx>\n';
                var blob = new Blob([xml], {
                    type: "application/gpx+xml;charset=utf-8"
                });
                saveAs(blob, filename + ".gpx");
                self.resolve();
            });
        });
    }

    function exportKml(filename) {
        return $.Deferred(function() {
            var self = this;
            try {
                var isFileSaverSupported = !! new Blob;
            } catch (e) {}
            if (!isFileSaverSupported) { /* can't check this until Blob polyfill loads above */
                return false;
            }
            var xml = '<?xml version="1.0" encoding="UTF-8"?>\n';
            xml += '<kml xmlns="http://www.opengis.net/kml/2.2" xmlns:gx="http://www.google.com/kml/ext/2.2" xmlns:kml="http://www.opengis.net/kml/2.2" xmlns:atom="http://www.w3.org/2005/Atom">\n';
            xml += '    <Document>\n';
            xml += '        <name>' + filename + '.kml</name>\n';
            xml += '        <Placemark>\n';
            xml += '            <name>' + filename + '</name>\n';
            xml += '            <LineString>\n';
            xml += '                <tessellate>1</tessellate>\n';
            xml += '                <coordinates>\n';
            xml += '                    ';
            $.each(routes, function(i, group) {
                group.eachLayer(function(layer) {
                    $.each(layer.feature.geometry.coordinates, function(j, coords) {
                        xml += coords[0] + ',' + coords[1] + ',0 ';
                    });
                });
            });
            xml += '\n                </coordinates>\n';
            xml += '            </LineString>\n';
            xml += '        </Placemark>\n';
            xml += '    </Document>\n';
            xml += '</kml>\n';
            var blob = new Blob([xml], {
                type: "text/plain;charset=utf-8"
            });
            saveAs(blob, filename + ".kml");
            self.resolve();
        });
    }

    function computeElevationMeasure() {
        var elevations = [];
        $.each(routes, function(i, group) {
            group.eachLayer(function(layer) {
                $.each(layer.feature.geometry.coordinates, function(j, coords) {
                    elevations.push({lat: coords[1], lon: coords[0], z: coords[2], slope: coords[3]});
                });
            });
        });

        if (elevations.length == 0) {
            return elevations;
        }

        var _decimalToRadian = function (location) {
            // from https://github.com/IGNF/geoportal-extensions/blob/master/src/Leaflet/Controls/Utils/PositionFormater.js
            var d = 0.01745329251994329577;
            var multiplier = Math.pow( 10, 8 );
            return Math.round( location * d * multiplier ) / multiplier;
        };

        /** Returns the distance from c1 to c2 using the haversine formula */
        var _haversineDistance = function (c1, c2) {
            var lat1 = _decimalToRadian(c1[1]);
            var lat2 = _decimalToRadian(c2[1]);
            var deltaLatBy2 = (lat2 - lat1) / 2;
            var deltaLonBy2 = _decimalToRadian(c2[0] - c1[0]) / 2;
            var a = Math.sin(deltaLatBy2) * Math.sin(deltaLatBy2) +
            Math.sin(deltaLonBy2) * Math.sin(deltaLonBy2) *
            Math.cos(lat1) * Math.cos(lat2);
            return 2 * 6378137 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        };

        // Calcul de la distance au départ pour chaque point + arrondi des lat/lon
        var distance = 0;
        var altMin = elevations[0];
        var altMax = elevations[0];
        var denivPos = 0;
        var denivNeg = 0;
        elevations[0].dist = 0;
        elevations[0].slopeOnTrack = 0;

        var elevationsResampled = [];
        elevationsResampled.push(elevations[0]);

        var j=0;
        for (var i = 1; i < elevations.length; i++) {
            var localDistance = _haversineDistance([elevations[i].lon, elevations[i].lat], [elevationsResampled[j].lon, elevationsResampled[j].lat]); // m
            if (localDistance > 10) {
                distance += localDistance / 1000;   // km

                elevationsResampled.push(elevations[i]);
                j++;

                elevationsResampled[j].dist = distance;
                elevationsResampled[j].slopeOnTrack = Math.atan((Math.round(elevationsResampled[j].z) - Math.round(elevationsResampled[j-1].z)) / localDistance) * 180 / Math.PI;

                if (j > 5) {
                    var previous = (elevationsResampled[j-5].slopeOnTrack + elevationsResampled[j-4].slopeOnTrack + elevationsResampled[j-3].slopeOnTrack + elevationsResampled[j-2].slopeOnTrack + elevationsResampled[j-1].slopeOnTrack) / 5
                    elevationsResampled[j].slopeOnTrack = (previous + elevationsResampled[j].slopeOnTrack) / 2;
                }

                if (elevationsResampled[j].z < altMin.z)
                    altMin = elevationsResampled[j];
                if (elevationsResampled[j].z > altMax.z)
                    altMax = elevationsResampled[j];

                if (elevationsResampled[j].z < elevationsResampled[j-1].z)
                    denivNeg += (Math.round(elevationsResampled[j-1].z) - Math.round(elevationsResampled[j].z));
                else
                    denivPos += (Math.round(elevationsResampled[j].z) - Math.round(elevationsResampled[j-1].z));
            }
        }

        $("#data-distance").text(Math.round(distance*100)/100 + "km");
        $("#data-alt-min").text(Math.round(altMin.z) + "m");
        $("#data-alt-max").text(Math.round(altMax.z) + "m");
        $("#data-deniv-pos").text(Math.round(denivPos) + "m");
        $("#data-deniv-neg").text(Math.round(denivNeg) + "m");

        return elevationsResampled;
    }

    var plotMarker = null;

    var ctx = $("#chart");
    var chart = new Chart(ctx, {
    type: 'line',
    data: {
        datasets: [{
            label: 'Altitude',
            data: [],
            fill: false,
            borderColor: 'rgba(12, 98, 173, 0.8)',
            backgroundColor: 'rgba(12, 98, 173, 0.8)',
            lineTension: 0,
            pointRadius: 0,
            yAxisId: 'alt'
        },{
            label: 'Slope on track',
            data: [],
            fill: true,
            //lineTension: 0,
            pointRadius: 0,
            yAxisID: 'slope'
        },{
            label: 'Slope',
            data: [],
            fill: true,
            //lineTension: 0,
            pointRadius: 0,
            yAxisID: 'slope2',
            hidden: true
        }]
    },
    options: {
        maintainAspectRatio: false,
        hover: {
            mode: 'index',
            intersect: false,
            onHover: function(event, active) {
                if (event.type == "mousemove") {
                    if (active && active.length > 0) {
                        var idx = active[0]._index;
                        var item = chart.config.data.datasets[0].data[idx];

                        if (plotMarker == null) {
                            plotMarker = L.marker(L.latLng(item.lat, item.lon), {
                                icon : new L.Icon.Default("orange"),
                                draggable : false,
                                clickable : false,
                                zIndexOffset : 1000
                            });

                            plotMarker.addTo(map);
                        } else {
                            plotMarker.setLatLng(L.latLng(item.lat, item.lon));
                            plotMarker.update();
                        }
                    } else {
                        if (plotMarker) {
                            map.removeLayer(plotMarker);
                            plotMarker = null;
                        }
                    }
                } else if (event.type == "mouseout") {
                    if (plotMarker) {
                        map.removeLayer(plotMarker);
                        plotMarker = null;
                    }
                }
            }
        },
        scales: {
            xAxes: [{
                type: 'linear',
                position: 'bottom',
                min: 0
            }],
            yAxes: [{
                id: 'alt',
                type: 'linear',
                position: 'left',
              }, {
                id: 'slope',
                type: 'linear',
                position: 'right'
              }, {
                id: 'slope2',
                type: 'linear',
                position: 'right',
                min: 0,
                max: 45
              }]
        },
        legend: {
            position: 'left'
        },
        tooltips: {
            mode: 'index',
            intersect: false,
            callbacks: {
                title: function(tooltipItems, data) {
                    return 'Distance: ' + Math.floor(tooltipItems[0].xLabel*100)/100 + "km";
                },
                label: function(tooltipItems, data) {
                    return data.datasets[tooltipItems.datasetIndex].label +': ' + Math.round(tooltipItems.yLabel*100)/100 + (tooltipItems.datasetIndex == 0 ? 'm' : '°');
                }
            }

        }
    }
    });
    function replot() {
        return $.Deferred(function() {
            var self = this;
            var elevations = computeElevationMeasure();

            var data = [];
            var data2 = [];
            var data3 = [];
            var maxSlope = 0;
            var minSlope = 0;
            for (var j = 0 ; j < elevations.length; j++) {
                data.push({x: elevations[j].dist, y: elevations[j].z, lat: elevations[j].lat, lon: elevations[j].lon});
                data2.push({x: elevations[j].dist, y: elevations[j].slopeOnTrack, lat: elevations[j].lat, lon: elevations[j].lon});
                data3.push({x: elevations[j].dist, y: elevations[j].slope, lat: elevations[j].lat, lon: elevations[j].lon});

                if (elevations[j].slopeOnTrack > maxSlope)
                    maxSlope = elevations[j].slopeOnTrack;
                if (elevations[j].slopeOnTrack < minSlope)
                    minSlope = elevations[j].slopeOnTrack;
            }
            if (data.length > 0) {
                chart.options.scales.xAxes[0].max = data[data.length-1].x;
                chart.config.data.datasets[0].data = data;
                chart.config.data.datasets[1].data = data2;
                chart.config.data.datasets[2].data = data3;

                var gradient = document.getElementById('chart').getContext('2d').createLinearGradient(0, 0, 0, 125);
                maxSlope = Math.ceil(maxSlope/10)*10;
                minSlope = Math.floor(minSlope/10)*10;

                var totalSlope = -minSlope + maxSlope;

                if (maxSlope >= 45) {
                    gradient.addColorStop((maxSlope-45)/totalSlope, 'purple');
                }
                if (maxSlope >= 40) {
                    gradient.addColorStop((maxSlope-40)/totalSlope, 'red');
                }
                if (maxSlope >= 35) {
                    gradient.addColorStop((maxSlope-35)/totalSlope, 'orange');
                }
                if (maxSlope >= 30) {
                    gradient.addColorStop((maxSlope-30)/totalSlope, 'yellow');
                }

                gradient.addColorStop(maxSlope/totalSlope, 'grey');

                if (minSlope <= -30) {
                    gradient.addColorStop((maxSlope+30)/totalSlope, 'yellow');
                }
                if (minSlope <= -35) {
                    gradient.addColorStop((maxSlope+35)/totalSlope, 'orange');
                }
                if (minSlope <= -40) {
                    gradient.addColorStop((maxSlope+40)/totalSlope, 'red');
                }
                if (minSlope <= -45) {
                    gradient.addColorStop((maxSlope+45)/totalSlope, 'purple');
                }
                chart.config.data.datasets[1].backgroundColor = gradient;


                var gradient2 = document.getElementById('chart').getContext('2d').createLinearGradient(0, 0, 0, 125);
                gradient2.addColorStop(0, 'purple');
                gradient2.addColorStop(1-40/45, 'red');
                gradient2.addColorStop(1-35/45, 'orange');
                gradient2.addColorStop(1-30/45, 'yellow');
                gradient2.addColorStop(1, 'grey');
                chart.config.data.datasets[2].backgroundColor = gradient2;
            } else {
                chart.options.scales.xAxes[0].max = 1;
                chart.config.data.datasets[0].data = [];
                chart.config.data.datasets[1].data = [];
                chart.config.data.datasets[2].data = [];
            }
            chart.update();
            self.resolve();
        });
    }
    replot();
}
    </script>
</body>
</html>
